'\"
'\" Copyright (c) 1993 The Regents of the University of California.
'\" Copyright (c) 1994-1997 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: upvar.ru.n,v 1.1.1.1 2003/10/16 19:01:11 alex Exp $
'\" 
.so man.macros
.TH upvar n "" Tcl "Tcl Built-In Commands"
.BS
'\" Note:  do not modify the .SH NAME line immediately below!
.SH NAME
upvar \- Создаёт ссылку на переменную, находящуюся на другом уровне в стеке
.SH SYNOPSIS
\fBupvar \fR?\fIуровень\fR? \fIвнешняяПеременная локальнаяПеременная \fR?\fIвнешняяПеременная локальнаяПеременная \fR...?
.BE

.SH DESCRIPTION
.PP
Эта команда создаёт одну или более локальных переменных текущей
процедуры таким образом, что они будут ссылаться на переменные из
процедур, вызвавших текущую, или на глобальные переменные. Аргумент
\fIуровень\fR может иметь тот же вид, что и в команде \fBuplevel\fR,
или может быть не указан, если первая буква первого аргумента
\fIвнешняяПеременная\fR отличается от символа \fB#\fR или цифры. По
умолчанию уровень равен \fB1\fR. Для каждого аргумента
\fIвнешняяПеременная\fR, команда \fBupvar\fR делает на указанном
\fIуровне\fR(или на глобальном, если \fIуровень\fR равен #0) вызова
вложенных процедур переменную с именем \fIвнешняяПеременная\fR
доступной в текущей процедуре с именем \fIлокальнаяПеременная\fR.
Если \fIвнешняяПеременная\fR не существует во время вызова, то она
будет создана при первом использовании \fIлокальнойПеременной\fR. В
момент выполнения команды \fBupvar\fR \fIлокальнаяПеременная\fR не
должна существовать. Аргумент \fIлокальнаяПеременная\fR всегда
рассматривается как имя переменной, но не элемента массива. Если имя
переменной похоже на обращение к элементу массива, например
\fBa(b)\fR, то все равно будет создана простая переменная с указанным
именем. Аргумент \fIвнешняяПеременная\fR может представлять собой имя
скалярной переменной, имя массива или ссылку на элемент массива.
\fBupvar\fR возвращает пустую строку.
.PP
Команда \fIupvar\fR упрощает передачу параметра по ссылке, а также
создание новых управляющих конструкций с помощью Tcl процедур.
Например, рассмотрим следующую процедуру:
.CS
\fBproc add2 name {
	upvar $name x
	set x [expr $x+2]
}\fR
.CE
Процедура \fBadd2\fR вызывается с аргументом, представляющим собой имя
переменной, значение которой необходимо увеличит на 2.
Этого же результата можно достичь с использованием команды
\fBuplevel\fR вместо \fBupvar\fR, \fBupvar\fR позволяет легче получать
доступ к переменной, находящейся на уровне вызывающей процедуры.
.PP
\fBnamespace eval\fR представляет другой способ (кроме вызовов
процедур) изменения контекста имён. Команда добавляет уровень вызова в
стек для отображения контекста пространства имён.
Это означает, что команда \fBnamespace eval\fR считается как ещё один
уровень вызова и его надо учитывать при использовании команд
\fBuplevel\fR и \fBupvar\fR.
Например, \fBinfo level 1\fR возвратит список, описывающий самую
верхнюю выполняемую процедуру или команду \fBnamespace eval\fR.
Команда \fBuplevel #0\fR выполняет соответствующий скрипт на самом
нижнем уровне (в глобальном пространстве имён).
.PP
.VS
Если переменная, созданная с помощью команды \fBupvar\fR, удаляется
(например, переменная \fBx\fR из процедуры \fBadd2\fR) с помощью
команды \fBunset\fR, то удалена будет переменная не указанная
переменная, а та, с которой указанная переменная связана. Нет способа
удалить переменные, созданные с помощью \fBupvar\fR, кроме как выйти
из процедуры, в которой они были созданы. Тем не менее, можно
перенацелить переменную, созданную с помощью \fBupvar\fR, выполнив ещё
раз эту команду.


.SH Трассировки и upvar
.PP
Upvar взаимодействует с трассировками простым, но несколько
неожиданным образом. Если существует трассировка для
\fIвнешнейПеременной\fR, то эта же трассировка будет применяться и к
\fIлокальнойПеременной\fR. При этом процедуре трассировки будет
передано имя \fIлокальнойПеременной\fR, а не
\fIвнешнейПеременной\fR. Таким образом, нижеследующий фрагмент кода
напечатает \fBlocalVar\fR, а не \fBoriginalVar\fR:
.CS
\fBproc traceproc { name index op } {
	puts $name
}
proc setByUpvar { name value } {
	upvar $name localVar
	set localVar $value
}
set originalVar 1
trace variable originalVar w traceproc
setByUpvar originalVar 2
\fR
.CE
Если \fIвнешняяПеременная\fR ссылается на элемент массива, то
трассировка, установленная на весь массив, не сработает, когда будет
осуществлён доступ к \fIлокальнойПеременной\fR (но индивидуальные
трассировки на элементы будут работать). В частности, в случае с
массивом \fBenv\fR, изменения, сделанные с \fIлокальнойПеременной\fR,
не будут корректно переданы подпроцессу.
.VE

.SH "SEE ALSO"
global(n), namespace(n), uplevel(n), variable(n)

.SH KEYWORDS
контекст, кадр, глобальный, уровень, пространство имён, процедура, переменная,
context, frame, global, level, namespace, procedure, variable
